##############################双人棋牌游戏服务端开发##############################
1.0版本  Socket+多线程
2.0版本  Socket+线程池+解耦合
3.0版本  Netty
4.0版本  当前版本

(一)技术栈说明
    Socket   多线程  线程池  动态线程池
    SpringBoot  Netty  Redis  MYSQL  Mybatis  RabbitMQ  

(二)yml文件配置说明
    服务端客户端通信端口 8888
    Redis和RabbitMQ 使用192.168.23.131 centos7虚拟机
    数据库为本地 cardgame

(三)五大模块 
    1.登陆注册  
    2.进入游戏
    3.查询游戏记录
    4.查询排行榜
    5.抢购欢乐豆  

(四)协议的制定
    使用ProtoBuf来作为协议
    id1   表明  登录注册等哪个功能模块的编号
    id2   表明  每个模块的信息
    id3   备用
    context   发送的消息String
    注册         1   -----handlerInfo   1  1 注册成功   1  2注册失败
    登录         2   -----handlerInfo   2  1 登录成功   2  2登陆失败
    查询游戏信息   3   -----handlerInfo
    查询排行榜    4   -----handlerInfo
    加入游戏     5    -----handlerPlay
    开始游戏     6    -----handlerPlay    服务端发给客户端  6.0.1 开始游戏(先出牌)  6.0.2开始游戏(后出牌)   6.1 context(用户出的牌)   6.2 context(用户的牌或者对手的牌出完了 本局比赛结束)
                                         客户端发给服务端  6.0 不要    6.1要
    退出游戏     7    -----handlerPlay
    抢购欢乐豆   8    -----handlerSecKill
    购买欢乐豆   9    -----handlerBuy    
    修改密码     10   -----handlerInfo
    刷新用户信息  11   -----handlerFlush   用于用户购买欢乐豆成功后刷新用户的balance happybean
    同步客户端和服务端的时间      0  ------handlerSyncTime

(五)实现细节
    总体：
    1.使用fireChannelRead(msg) 可以使得msg在handler中继续传递
    (1)登录和注册
        使用了redis作为缓存，缓存用户的信息
        如何解决缓存穿透 和 缓存雪崩
        缓存穿透：参考mybatis的二级缓存  将数据库中没有的数据也插入到redis中
            在客户端限制客户的发送验证请求的次数 使用了定时任务
        缓存雪崩：两种情况，第一种是超时时间设置的一样，某个时间点请求打到数据库上
            第二种是redis宕机了
            解决方法：设置不同的过期时间的策略
                    使用主从复制和哨兵模式 搭建redis集群
    2.查询历史游戏记录
        如何实现分页功能？
    3.查询排行榜前十名
        (1)从synchronized到readwriteLock的升级
        (2)死锁的排查过程   readwriteLock 读锁中又出现了写锁
    4.加入游戏模块
        生产者消费者的思想解决
    5.开始游戏模块
        遇到了一个Bug @Data的使用
	    使用了异步线程池
    6.秒杀系统的设计
        (一)关于mysql级别解决数据库的超卖问题
            (1)减库存的sql语句上加上库存数量的判断。数据库滋生是有行锁的，每次减库存的时候
            判断count>0,实际上是串行的执行update。
            (2)实现乐观锁，给商品信息表增加了version字段，为每一条数据加上版本。每次更新的时候
            version+1，并且更新的时候带上版本号，当提交前版本号等于更新前版本号，说明此时没有被其他
            线程影响到，正常更新，如果冲突了就不会进行提交更新。当库存是足够的情况下发生乐观锁冲突就
            进行一定次数的重试。
        (二)减库存的操作
            (1)拍下减库存   目前采用拍下减库存 拍下就是一瞬间的事情，对用户的体验更好。
            (2)付款减库存
        具体流程：
        1.如何实现客户端和服务端时间的同步操作 
        1.使用springboot中的定时任务，每周六周天晚上八点更新redis和mysql中的信息  八点半删除redis和mysql中秒杀商品的信息
        2.用户发来秒杀的请求。首先判断用户的happybean和时间是否合法以及是否重购买。
        3.进入秒杀流程中
        4.三级判断  JVM的内存标记    redis中的库存是否充足
        5.如果充足的话那么预减redis的库存  (LUA脚本)
        6.然后给MQ的队列中发送一条消息，MessageInfo发给队列。
        7.消费者消费这个消息。 判断mysql中的库存是否充足，判断是否重复购买。(mysql中要加锁 并且设置组合索引)
        8.客户端轮询这个订单的状态。如果是在mysql中，那么插入成功，秒杀成功。  
        如果没有插入成功并且redis中这个货物的状态变为0(mysql执行减库存后判断库存数量=0设置这个标记)
        else  返回正在处理中。
    10.修改用户信息  如何保证数据库和redis的双写一致性
        CAP理论决定的，属于CAP中的AP。做到BASE理论的最终一致性。
        使用了延时双删策略。(先删除缓存 再次更新数据库  休眠一段时间再删除缓存)
        保证读请求结束，写请求可以删除读请求造成的缓存脏数据。
        关于update加锁的问题，如果是where后的列带索引加的是行锁，锁住索引。而且加了X锁。
        如果where条件没有使用索引，那就全局扫描。锁住了整张表

        

    


(六)面试
    1.ThreadLocal的应用  内存泄露
    2.对jvm的优化
    3.如何去解除死锁 发现死锁
    4.缓存击穿  缓存穿透 缓存雪崩的处理
    5.分页如何处理
    6.如何保证数据库和缓存的一致性
    7.用户取消订单怎么处理
    8.MQ延时队列 
    8.Netty中使用ThreadLocal在多个handler中进行变量的传播操作
    

(七)出现了问题 栈溢出的bug 循环依赖
    应该是UserVo中含有了User 还有一个UserVo的类
    未解决
    解决方法1：将UserVo中里面的User变量替换掉
    使用基本的数据类型来解决
    问题发现：是@Data注解带来的问题 因为UserVo的类中含有UserVo的引用 导致引用的循环依赖造成了栈溢出

(八)redis和mysql的缓存一致性的问题
1. redis做缓存的流程  
   1. 命中:先从缓存中读数据，如果命中，直接返回。
   2. 失效：先从缓存中读数据，如果没有命中，从数据库中读取，成功之后将数据放回缓存。
   3. 更新：先更新数据库再删除缓存。
2 .各种方案
      1. 先更新缓存再更新数据库  A更新缓存 B更新缓存 B更新数据库  A更新数据库 数据不一致
      2. 先更新数据库再更新缓存  A更新数据库 B更新数据库  B更新缓存  A更新缓存
      3. 先删除缓存再更新数据库  A删除缓存   B读取缓存发现不存在读数据库  A跟新数据库 B更新缓存  数据不一致
      4. 先更新数据库再删除缓存
         不正常的概率很小
         (1)正常的情况。先前缓存更好失效。A请求查数据库得到旧值A=1  B请求更新数据库 A=2  A请求将A=1写到缓存  B请求删除缓存
         (2)不正常情况。先前缓存刚好失效。A请求查数据库得到旧值A=1  B请求更新数据库 A=2  B请求删除缓存   A请求将旧值写入缓存 数据不一致性
         (3)解决方法：延时删除  请求B休眠100ms，等到请求A写入缓存之后再次删除
        
      5. 读写分离(主库复杂写 从库复杂读)
      用延时双删还是会出现问题
      解决方法 添加一个订阅binlog服务系统 主数据库更新后直接从订阅系统中 将redis的数据更新
      
      6. 更新缓存失败如何处理？
      增加一个消息队列 将更新缓存的数据放到MQ当中，消息队列中的消息是有序的并且可以进行持久化操作
      还能支持重试策略

3. 更新缓存的问题
   1. 如果跟新缓存逻辑复杂，更新缓存消耗大于直接淘汰cache。


4.关于数据库的乐观锁和悲观锁
    1.悲观锁。行锁，表锁，排他锁都是悲观锁。使用select for update语句，执行后会在表上加行锁，直到事务提交。解除行锁。
    2.乐观锁。多个线程同时CAS更新一个变量时候，只有一个线程能够更新成功。失败的线程不会被挂起。可以再次尝试。





缓存穿透
缓存穿透是指查询⼀个数据库⼀定不存在的数据。
⾼并发下，⼀秒钟前⼀百个请求向数据库请求，第⼀百零⼀个数据发现 缓存有了，就去访
问缓存，⽆影响。
⾼并发下，⼀秒钟⼀百万个请求都去请求⼀个数据，但是缓存没有，再去请求数据库，数
据库⾥也不存在，此时，这⼀百万个请求已经和数据库交互了。所以叫做绕过缓存，把
redis缓存数据库穿透了。
想象⼀下，uuid查询，很容易找到⼀个不存在的key，恶意攻击，利⽤这个漏洞，很容易给
服务器带来巨⼤的压⼒。
解决⽅案：把不存在的给个null，放⼊缓存，可以防⽌攻击⽤户反复⽤同⼀个id暴⼒攻击。
缓存雪崩
缓存雪崩：
指缓存中数据⼤批量到过期时间甚⾄缓存服务器宕机，⽽查询数据量巨⼤，引起数据库压
⼒过⼤甚⾄宕机。
和缓存击穿不同的是，缓存击穿指并发查同⼀条数据，缓存雪崩是不同数据都过期了，很
多数据都查不到从⽽查数据库。
解决⽅案：⼀般采取不同分类商品，设计随机因⼦，缓存不同周期。
缓存击穿
描述：缓存击穿是指缓存中没有但数据库中有的数据（⼀般是缓存时间到期），这时由于并发⽤
户特别多，同时读缓存没读到数据，⼜同时去数据库去取数据，引起数据库压⼒瞬间增⼤，造成
过⼤压⼒。
例⼦：爆款
解决⽅案：
设置热点数据永远不过期。

2022.5.1项目基本完成

1.bug1  用户游戏完成 没有进行结算工作  内存中的数据更改  数据库的数据更改  添加历史记录中 












(一)数据库
    (1) 数据库表设计
    user            id     name    password         
    account         id     balance  happybean
    note            idme   idops    happybean
    goods           id     goodname   price    happybean  
    seckillgoods    id     goodname   price    happybean stock  version   startDate  endDate
    order           id     userid     goodsid  price   happybean  goodsname  date
    (2) 为何如此设计
        (2.1) 手机号是主键 password是两次加密的md5  为何name使用varchar(30) password使用char(36)    
        从mysql的层面来看 varchar可变长度的字符串  char是定长的字符串  很显然每个用户的用户名都不同 使用varchar节省空间 但是也带来了一个弊端
        就是当用户进行修改的时候，可能会出现长度过大造成了页分裂的问题(分裂页来存放这一行)  因为md5加盐加密后的字符串是固定的36个字符 使用char类型
        (2.2) 有goods和seckillGoods两个表 一个没有stock和version和startDate和endDate
        因为普通的购买欢乐豆的情况不需要库存
        (2.3) order表中使用了 (userid,goodsid)作为唯一索引 解决用户重复下单的问题
        (2.4) 对于happybean加了索引优化后 万行数据查询的时间减少了 ms

(二)功能介绍
    (1)用户信息的登录注册修改功能。   
        1.使用Mysql来实现。但是每次都是要访问数据库。在高并发比较高的情况下，瓶颈在 IO 上（网络IO和磁盘IO上），并不在内存和CPU上。
        减少数据库磁盘 IO 时间最有效的办法是使用缓存。还可以将数据库弄成 master/slave 的读写分离，分表分库等等。
        2.MyBatis中有两个缓存，sqlSession级别的一级缓存，Mapper级别的二级缓存。默认只是开启了一级缓存。 使用了二级缓存需要手动开启。
        3.后期学习了一些分布式的知识，意识到项目应该朝着分布式的方法去发展。但是Mybatis默认二级缓存只是本地。考虑使用mybatis整合redis实现二级缓存。
        4.直接使用Redis作为缓存。需要考虑缓存一致性的问题。
    (2)用户申请加入游戏,开始游戏,退出游戏功能。
    (3)用户查询历史记录。
    (4)实时获取欢乐豆排行榜前十名的功能。
    (5)购买欢乐豆和抢购欢乐豆。
        衍生的问题
        (一)用户信息的登录注册修改
        (一.1)关于Mybatis的问题
            1.使用mybatis的一般步骤   
                (1).在pom文件中添加mybatis和mysql的依赖。 
                (2).创建接口，里面是增删查改的方法。
                (3).创建mapper.xml文件，里面有namespace,定位哪个接口， 里面标签中有id，定位接口中的哪个方法。
                (4).创建config.xml文件，配置mybatis相关的信息，最重要的是一个<mapper>标签。写上mapper.xml的文件位置。
                (5).创建配置文件，然后生成SqlSessionFactory。
                (6).通过SqlSessionFactory生成了sqlSession。(注意这里的sqlSession线程不安全)可以通过sqlSession直接查询，也可以转化成mapper接口查询。
            2.mybatis的ORM框架的原理。
                (1)首先是mapper.xml文件中对类路径的绑定，里面的namespace和id已经传入的参数。
                (2)发送这些数据给mysql，mysql只能帮我们查询到数据。
                (3)返回到Mybatis中，然后mybatis根据这些类路径，通过反射获取到这个类，然后new一个对象。
                (4)通过绑定的关系，然后set到对象的属性中，然后返回。
            3.mybatis的缓存问题
                (1)一级缓存，默认开启，是sqlSession级别的缓存，本质上就是hashMap。
                (2)二级缓存，需要配置开启，Mapper级别缓存。多个sqlSession共享。 cacheEnable 
                (3)mybatis整合redis缓存的实现。
                    因为二级缓存占用的是JVM的堆空间，使用redis进行实现。重写了mybatis的cache将缓存映射到redis中。
                    (3.1)sqlSessionFactory的二级缓存是PerpetualCache实现了Cache接口。里面本质上是一个HashMap来记录。通过这个hashmap缓存查询出来的值。
                    (3.2)在config文件中开启二级缓存 setting name=cacheEnable value=true  在.xml文件设置cache
                    (3.3)使用redis来实现Cache接口重写几个方法。获取id(每个Dao接口都有一个唯一的id)。
                    (3.4)使用redis的hash来实现。  hash中的id是dao接口的名字，也就是一张表的访问一个id。key其实是具体的函数。(select id select all等等 )
                    value是这个查询的结构，存放到了redis中。  主要写putObject()  getObject()  clear()
                    缺点：1.key比较大的时候，占用了redis的内存，在一定程度上影响了redis的性能。
                    2.如果是使用update，导致整个的缓存失效。影响的业务很大。命中率比较低。
                    3.多个表的情况下还有问题，可以通过其他表ref属性来解决。
            4.mybatis如何防止sql注入的风险
                例子  select * from table where id=or 1=1 (or一定会成功执行)
                在前端或者后端对参数进行校验拦截。
                mybatis中的mapper文件中，有#{}和${}两种。
                当查询之气那，mybaits对文件进行动态解析。
                #{}是预编译，也就是编译好了sql语句，参数只是一个占位符。
                ${}没有预编译，当传入参数之后，生成sql语句交给mysql。
                所以有效的防止了sql注入的风险。
            5.sqlSession的线程不安全。 (ThreadLoacl解决方案)
                发现问题是在于一开始开发没有注意到线程安全问题。使用了一个单例模式来构建sqlSession。
                当两个用户游戏的时候，一个用户退出，导致另外的用户sqlSession也关闭。 查询官方文档说sqlSession线程不安全。
                查看源码 SqlSession中执行一个查询语句的源码
                    (1)从hashmap中查询
                    (2)从mysql中查询
                    (3)将mysql中的数据放到hasmap中。
                一开始来说，比如现在有三个线程同时使用了sqlSession。第一个线程执行了select 
                第二个线程执行了select  第三个线程执行了insert
                第一个线程从map中找没有找到，然后从数据库中查询。查询了5条数据 这时候还没有放到map中。
                第二个线程执行了一个insert语句完成。(时间片轮转)
                第三个线程执行力select从mysql查找了6条数据，并且存放到mybatis中完成。
                然后第一个线程存放到map中完成，后来的数据都是错误的。
                解决线程安全的三种方案。(周志明老师深入了解Java虚拟机分析)同步阻塞，同步非阻塞和无同步方案。
                因为这种同步阻塞和同步非阻塞方法涉及到对共享资源的竞争。那么导致效率急剧下降。考虑使用无同步方案。
                也就是线程自己有一个sqlSession这样就没有线程安全问题，同时深入理解Java虚拟机作者也提到了ThreadLoacl。
            6.如何使用ThreadLocal来解决sqlSession线程不安全
                阅读线程类的源码可以看到有 ThreadLocalMap 这里面其实就是存储了key就是threadlocal的引用，value就是真正的值。
                (1)创建一个 static ThreadLocal<SqlSession>threadLocalSql 的对象
                (2)当业务种有使用sqlSession的时候那就通过提供的get() 里面 if(threadlocalSql.get()==null) 创建一个新的sqlSession，通过set方法存放到thread种。
                从源码的角度来看，其实threadLocalMap种存放的是Entry对象继承了弱引用。但是value是强引用。调用threadlocalsql其实先获取当前线程，然后从当前线程的threadlocalMap去查询。
                (3)当使用完的时候注意释放sqlSessioni。一开始没有考虑。压测的时候发现了内存泄露的问题。
                    如何释放，先获取到SqlSession，然后关闭，然后threadlocalSql.remove()将value删除。
                
                
                
                




        2.关于Redis的问题
        

    


(三)亮点难点
    系统层面：如何保证线程安全，如何提高项目的并发量和QPS。
    用户层面：如何保证用户信息安全(用户密码的二次加密，MD5加盐，防止sql注入)，如何提升游戏体验(响应时间，心跳检测，半连接队列攻击)


(四)系统架构升级
    1.SocketBIO+多线程
    2.SocketBIO+线程池
    3.使用NIO(未完成)
    4.使用Netty
    5.使用Springboot+Netty





    












