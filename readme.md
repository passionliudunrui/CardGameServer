##############################双人棋牌游戏服务端开发##############################
1.0版本  Socket+多线程
2.0版本  Socket+线程池+解耦合
3.0版本  Netty
4.0版本  当前版本

(一)技术栈说明
    Socket   多线程  线程池  动态线程池
    SpringBoot  Netty  Redis  MYSQL  Mybatis  RabbitMQ  

(二)yml文件配置说明
    服务端客户端通信端口 8888
    Redis和RabbitMQ 使用192.168.23.131 centos7虚拟机
    数据库为本地 cardgame

(三)五大模块 
    1.登陆注册  
    2.进入游戏
    3.查询游戏记录
    4.查询排行榜
    5.抢购欢乐豆  

(四)协议的制定
    使用ProtoBuf来作为协议
    id1   表明  登录注册等哪个功能模块的编号
    id2   表明  每个模块的信息
    id3   备用
    context   发送的消息String
    注册         1   -----handlerInfo   1  1 注册成功   1  2注册失败
    登录         2   -----handlerInfo   2  1 登录成功   2  2登陆失败
    查询游戏信息   3   -----handlerInfo
    查询排行榜    4   -----handlerInfo
    加入游戏     5    -----handlerPlay
    开始游戏     6    -----handlerPlay    服务端发给客户端  6.0.1 开始游戏(先出牌)  6.0.2开始游戏(后出牌)   6.1 context(用户出的牌)   6.2 context(用户的牌或者对手的牌出完了 本局比赛结束)
                                         客户端发给服务端  6.0 不要    6.1要
    退出游戏     7    -----handlerPlay
    抢购欢乐豆   8    -----handlerSecKill
    购买欢乐豆   9    -----handlerBuy    
    修改密码     10   -----handlerInfo
    刷新用户信息  11   -----handlerFlush   用于用户购买欢乐豆成功后刷新用户的balance happybean
    同步客户端和服务端的时间      0  ------handlerSyncTime

(五)实现细节
    总体：
    1.使用fireChannelRead(msg) 可以使得msg在handler中继续传递
    (1)登录和注册
        使用了redis作为缓存，缓存用户的信息
        如何解决缓存穿透 和 缓存雪崩
        缓存穿透：参考mybatis的二级缓存  将数据库中没有的数据也插入到redis中
            在客户端限制客户的发送验证请求的次数 使用了定时任务
        缓存雪崩：两种情况，第一种是超时时间设置的一样，某个时间点请求打到数据库上
            第二种是redis宕机了
            解决方法：设置不同的过期时间的策略
                    使用主从复制和哨兵模式 搭建redis集群
    2.查询历史游戏记录
        如何实现分页功能？
    3.查询排行榜前十名
        (1)从synchronized到readwriteLock的升级
        (2)死锁的排查过程   readwriteLock 读锁中又出现了写锁
    4.加入游戏模块
        生产者消费者的思想解决
    5.开始游戏模块
        遇到了一个Bug @Data的使用
	    使用了异步线程池
    6.秒杀系统的设计
        (一)关于mysql级别解决数据库的超卖问题
            (1)减库存的sql语句上加上库存数量的判断。数据库滋生是有行锁的，每次减库存的时候
            判断count>0,实际上是串行的执行update。
            (2)实现乐观锁，给商品信息表增加了version字段，为每一条数据加上版本。每次更新的时候
            version+1，并且更新的时候带上版本号，当提交前版本号等于更新前版本号，说明此时没有被其他
            线程影响到，正常更新，如果冲突了就不会进行提交更新。当库存是足够的情况下发生乐观锁冲突就
            进行一定次数的重试。
        (二)减库存的操作
            (1)拍下减库存   目前采用拍下减库存 拍下就是一瞬间的事情，对用户的体验更好。
            (2)付款减库存
        具体流程：
        1.如何实现客户端和服务端时间的同步操作 
        1.使用springboot中的定时任务，每周六周天晚上八点更新redis和mysql中的信息  八点半删除redis和mysql中秒杀商品的信息
        2.用户发来秒杀的请求。首先判断用户的happybean和时间是否合法以及是否重购买。
        3.进入秒杀流程中
        4.三级判断  JVM的内存标记    redis中的库存是否充足
        5.如果充足的话那么预减redis的库存  (LUA脚本)
        6.然后给MQ的队列中发送一条消息，MessageInfo发给队列。
        7.消费者消费这个消息。 判断mysql中的库存是否充足，判断是否重复购买。(mysql中要加锁 并且设置组合索引)
        8.客户端轮询这个订单的状态。如果是在mysql中，那么插入成功，秒杀成功。  
        如果没有插入成功并且redis中这个货物的状态变为0(mysql执行减库存后判断库存数量=0设置这个标记)
        else  返回正在处理中。
    10.修改用户信息  如何保证数据库和redis的双写一致性
        CAP理论决定的，属于CAP中的AP。做到BASE理论的最终一致性。
        使用了延时双删策略。(先删除缓存 再次更新数据库  休眠一段时间再删除缓存)
        保证读请求结束，写请求可以删除读请求造成的缓存脏数据。
        关于update加锁的问题，如果是where后的列带索引加的是行锁，锁住索引。而且加了X锁。
        如果where条件没有使用索引，那就全局扫描。锁住了整张表



(六)面试
    1.ThreadLocal的应用  内存泄露
    2.对jvm的优化
    3.如何去解除死锁 发现死锁
    4.缓存击穿  缓存穿透 缓存雪崩的处理
    5.分页如何处理
    6.如何保证数据库和缓存的一致性
    7.用户取消订单怎么处理
    8.MQ延时队列 
    8.Netty中使用ThreadLocal在多个handler中进行变量的传播操作
    

(七)出现了问题 栈溢出的bug 循环依赖
    应该是UserVo中含有了User 还有一个UserVo的类
    未解决
    解决方法1：将UserVo中里面的User变量替换掉
    使用基本的数据类型来解决
    问题发现：是@Data注解带来的问题 因为UserVo的类中含有UserVo的引用 导致引用的循环依赖造成了栈溢出

(八)redis和mysql的缓存一致性的问题
1. redis做缓存的流程  
   1. 命中:先从缓存中读数据，如果命中，直接返回。
   2. 失效：先从缓存中读数据，如果没有命中，从数据库中读取，成功之后将数据放回缓存。
   3. 更新：先更新数据库再删除缓存。
2 .各种方案
      1. 先更新缓存再更新数据库  A更新缓存 B更新缓存 B更新数据库  A更新数据库 数据不一致
      2. 先更新数据库再更新缓存  A更新数据库 B更新数据库  B更新缓存  A更新缓存
      3. 先删除缓存再更新数据库  A删除缓存   B读取缓存发现不存在读数据库  A更新数据库 B更新缓存  数据不一致
      4. 先更新数据库再删除缓存
         不正常的概率很小
         (1)正常的情况。先前缓存更好失效。A请求查数据库得到旧值A=1  B请求更新数据库 A=2  A请求将A=1写到缓存  B请求删除缓存
         (2)不正常情况。先前缓存刚好失效。A请求查数据库得到旧值A=1  B请求更新数据库 A=2  B请求删除缓存   A请求将旧值写入缓存 数据不一致性
         (3)解决方法：延时删除  请求B休眠100ms，等到请求A写入缓存之后再次删除
      5. 延时双删
         先删除缓存   然后修改数据库  然后再次删除缓存
      6. 读写分离(主库复杂写 从库复杂读)
      用延时双删还是会出现问题
      解决方法 添加一个订阅binlog服务系统 主数据库更新后直接从订阅系统中 将redis的数据更新
      
      7. 更新缓存失败如何处理？
      增加一个消息队列 将更新缓存的数据放到MQ当中，消息队列中的消息是有序的并且可以进行持久化操作
      还能支持重试策略


4.关于数据库的乐观锁和悲观锁
    1.悲观锁。行锁，表锁，排他锁都是悲观锁。使用select for update语句，执行后会在表上加行锁，直到事务提交。解除行锁。
    2.乐观锁。多个线程同时CAS更新一个变量时候，只有一个线程能够更新成功。失败的线程不会被挂起。可以再次尝试。













(一)数据库
    (1) 数据库表设计
    user            id     name    password         
    account         id     balance  happybean
    note            idme   idops    happybean
    goods           id     goodname   price    happybean  
    seckillgoods    id     goodname   price    happybean stock  version   startDate  endDate
    order           id     userid     goodsid  price   happybean  goodsname  date
    (2) 为何如此设计
        (2.1) 手机号是主键 password是两次加密的md5  为何name使用varchar(30) password使用char(36)    
        从mysql的层面来看 varchar可变长度的字符串  char是定长的字符串  很显然每个用户的用户名都不同 使用varchar节省空间 但是也带来了一个弊端
        就是当用户进行修改的时候，可能会出现长度过大造成了页分裂的问题(分裂页来存放这一行)  因为md5加盐加密后的字符串是固定的36个字符 使用char类型
        (2.2) 有goods和seckillGoods两个表 一个没有stock和version和startDate和endDate
        因为普通的购买欢乐豆的情况不需要库存
        (2.3) order表中使用了 (userid,goodsid)作为唯一索引 解决用户重复下单的问题
        (2.4) 对于happybean加了索引优化后 万行数据查询的时间减少了 ms

(二)功能介绍
    (1) 用户信息的登录注册修改功能。   
        1. 使用Mysql来实现。但是每次都是要访问数据库。当然添加了索引。在高并发比较高的情况下，瓶颈在 IO 上（网络IO和磁盘IO上），并不在内存和CPU上。
        减少数据库磁盘 IO 时间最有效的办法是使用缓存。还可以将数据库弄成 master/slave 的读写分离，分表分库等等。
        2. MyBatis中有两个缓存，sqlSession级别的一级缓存，Mapper级别的二级缓存。默认只是开启了一级缓存。 使用了二级缓存需要手动开启。
        后期学习了一些分布式的知识，意识到项目应该朝着分布式的方法去发展。但是Mybatis默认二级缓存只是本地。并且缓存占用了JVM的堆空间，增加了GC的压力。
        3. 考虑使用mybatis整合redis实现二级缓存。但是只要有一个update，所有的缓存数据都失效。成本比较大。考虑直接使用redis实现。
        4. 直接使用Redis作为缓存。需要考虑缓存一致性的问题。(防止缓存穿透和雪崩 使用了布隆过滤器和随机过期时间)
    (2) 用户申请加入游戏,开始游戏,退出游戏功能。
        1. 加入游戏功能。
            其实也就是找当当前玩游戏的人一起玩游戏，定位是一款双人游戏，并且先进行匹配的人应该先开始玩游戏。并且有两个人加入游戏就可以进行匹配。
            其实就是生产者消费者模型。需要一个线程安全的队列来支持。从选择上来看 ConcurrentLinkedQueue  LinkedBlockQUeue  ArrayBlockQueue 
            使用了offer进行加入元素，因为要防止内存溢出的风险。 用户调用offer，如果失败提示用户系统繁忙就行。
        2. 匹配游戏功能。
            (1) 一开始想的更加复杂。一个用户请求开始游戏需要三个线程来实现，现在看来是非常不合理的。用ReveiveThread ManagerThread  RoomThread  涉及到线程通信问题
            (2) 取消了RoomThread。在Netty中，直接用户请求加入游戏后，客户端接收到消息后，不提供输入功能操作，只提供一个取消匹配的操作。取消匹配就是从阻塞队列中取出元素。
        3. 退出游戏，那就关闭相关的资源，删除map中的关于player的信息。     
    (3) 用户查询历史记录。
        用户查看历史记录的时候，可能这个用户的历史记录非常多，并且用户可能只想看最近几条记录。那么使用分页来解决。
        (1)使用list进行实现。也就是查到的数据存放到了JVM的堆中，然后进行分片处理，占用内存不推荐使用。
        (2)RowBounds分页，本质上也是在内存进行实现。
        (3)sql分页，传入数据由mysql负责分页。
        (4)分页插件，基于拦截器进行实现。根据传入的参数重写了sql语句。 分页插件实现intercepter拦截器。重写拦截器的方法。拿到原始的sql，添加limit关键字，本质还是交给mysql执行。
    (4) 实时获取欢乐豆排行榜前十名的功能。
        (1)直接通过mysql进行查询。
        (2)给mysql添加索引。
        (3)定时进行查询mysql并且存放到内存中。并不是实时的。
        (4)实现的skiplist
            (1)能够进行实时的更新。
            (2)能够根据先达到这个分数的user进行排名。
            (3)性能好
            (4)线程安全
    (5) 购买欢乐豆和抢购欢乐豆。
        衍生的问题
        (一)用户信息的登录注册修改
        (一.1)关于Mybatis的问题
            1. 使用mybatis的一般步骤   
                (1).在pom文件中添加mybatis和mysql的依赖。 
                (2).创建接口，里面是增删查改的方法。
                (3).创建mapper.xml文件，里面有namespace,定位哪个接口， 里面标签中有id，定位接口中的哪个方法。
                (4).创建config.xml文件，配置mybatis相关的信息，最重要的是一个<mapper>标签。写上mapper.xml的文件位置。
                (5).创建配置文件，然后生成SqlSessionFactory。
                (6).通过SqlSessionFactory生成了sqlSession。(注意这里的sqlSession线程不安全)可以通过sqlSession直接查询，也可以转化成mapper接口查询。
            2. mybatis的ORM框架的原理。
                (1)首先是mapper.xml文件中对类路径的绑定，里面的namespace和id已经传入的参数。
                (2)发送这些数据给mysql，mysql只能帮我们查询到数据。
                (3)返回到Mybatis中，然后mybatis根据这些类路径，通过反射获取到这个类，然后new一个对象。
                (4)通过绑定的关系，然后set到对象的属性中，然后返回。
            3. mybatis的缓存问题
                (1) 一级缓存，默认开启，是sqlSession级别的缓存，本质上就是hashMap。
                (2) 二级缓存，需要配置开启，Mapper级别缓存。多个sqlSession共享。 cacheEnable 
                (3) mybatis整合redis缓存的实现。
                    因为二级缓存占用的是JVM的堆空间，使用redis进行实现。重写了mybatis的cache将缓存映射到redis中。
                    (3.1) sqlSessionFactory的二级缓存是PerpetualCache实现了Cache接口。里面本质上是一个HashMap来记录。通过这个hashmap缓存查询出来的值。
                    (3.2) 在config文件中开启二级缓存 setting name=cacheEnable value=true  在.xml文件设置cache
                    (3.3) 使用redis来实现Cache接口重写几个方法。获取id(每个Dao接口都有一个唯一的id)。
                    (3.4) 使用redis的hash来实现。  hash中的id是dao接口的名字，也就是一张表的访问一个id。key其实是具体的函数。(select id select all等等 )
                    value是这个查询的结构，存放到了redis中。  主要写putObject()  getObject()  clear()
                    缺点：1.key比较大的时候，占用了redis的内存，在一定程度上影响了redis的性能。
                    2. 如果是使用update，导致整个的缓存失效。影响的业务很大。命中率比较低。
                    3. 多个表的情况下还有问题，可以通过其他表ref属性来解决。
            4. mybatis如何防止sql注入的风险
                例子  select * from table where id=or 1=1 (or一定会成功执行)
                在前端或者后端对参数进行校验拦截。
                mybatis中的mapper文件中，有#{}和${}两种。
                当查询之气那，mybaits对文件进行动态解析。
                #{}是预编译，也就是编译好了sql语句，参数只是一个占位符。
                ${}没有预编译，当传入参数之后，生成sql语句交给mysql。
                所以有效的防止了sql注入的风险。
            5. sqlSession的线程不安全。 (ThreadLoacl解决方案)
                发现问题是在于一开始开发没有注意到线程安全问题。使用了一个单例模式来构建sqlSession。
                当两个用户游戏的时候，一个用户退出，导致另外的用户sqlSession也关闭。 查询官方文档说sqlSession线程不安全。
                查看源码 SqlSession中执行一个查询语句的源码
                    (1)从hashmap中查询
                    (2)从mysql中查询
                    (3)将mysql中的数据放到hasmap中。
                一开始来说，比如现在有三个线程同时使用了sqlSession。第一个线程执行了select 
                第二个线程执行了select  第三个线程执行了insert
                第一个线程从map中找没有找到，然后从数据库中查询。查询了5条数据 这时候还没有放到map中。
                第二个线程执行了一个insert语句完成。(时间片轮转)
                第三个线程执行力select从mysql查找了6条数据，并且存放到mybatis中完成。
                然后第一个线程存放到map中完成，后来的数据都是错误的。
                解决线程安全的三种方案。(周志明老师深入了解Java虚拟机分析)同步阻塞，同步非阻塞和无同步方案。
                因为这种同步阻塞和同步非阻塞方法涉及到对共享资源的竞争。那么导致效率急剧下降。考虑使用无同步方案。
                也就是线程自己有一个sqlSession这样就没有线程安全问题，同时深入理解Java虚拟机作者也提到了ThreadLoacl。
            6. 如何使用ThreadLocal来解决sqlSession线程不安全
                阅读线程类的源码可以看到有 ThreadLocalMap 这里面其实就是存储了key就是threadlocal的引用，value就是真正的值。
                (1) 创建一个 static ThreadLocal<SqlSession>threadLocalSql 的对象
                (2) 当业务种有使用sqlSession的时候那就通过提供的get() 里面 if(threadlocalSql.get()==null) 创建一个新的sqlSession，通过set方法存放到thread种。
                从源码的角度来看，其实threadLocalMap种存放的是Entry对象继承了弱引用。但是value是强引用。调用threadlocalsql其实先获取当前线程，然后从当前线程的threadlocalMap去查询。
                (3) 当使用完的时候注意释放sqlSessioni。一开始没有考虑。压测的时候发现了内存泄露的问题。
                    如何释放，先获取到SqlSession，然后关闭，然后threadlocalSql.remove()将value删除。
                spring暴力springboot整合mybatis默认使用了sqlSessionTemplate。
                本质上也是通过ThreadLoca来进行获取。只不过在这之前通过动态代理来实现。我认为是spring不去侵入mybatis的源码，增加耦合在动态代理中实现。
        (一.2)关于redis的问题
            1. 缓存穿透，缓存击穿，缓存雪崩问题以及解决方案。
                (1) 缓存穿透指的是查询的都是redis不存在并且mysql也不存在的数据，比如id=-1,或者是UUID这种情况。
                解决：1.参考mybatis的二级缓存，将mysql查询不到的数据也放到redis中，设置为空。  2.使用布隆过滤器来实现。
                (2) 缓存击穿指的是对某个热点数据key访问量非常大，但是在某一个时间失效了，很多请求打到mysql上。
                解决：1.设置缓存永不过期，有风险，内存淘汰策略(使用定时任务刷新)。 
                     2.分布式锁来解决。 具体是：当多个线程查询缓存没有的时候，多个线程竞争同一个分布式锁(redis中的setnx或者zk)只允许一个线程重建缓存。
                     其他没有竞争锁的线程等待。
                (3) 缓存雪崩指的是多个热点数据key访问量非常大，并且同一时间失效，大量请求打到mysql或者是redis宕机了。
                解决：1.高可用解决方案。  2.分散key的过期时间。  3.分布式锁，缓存失效的时候竞争分布式锁，然后更新缓存。
            2. 如何实现布隆过滤器
                布隆过滤器非常像一个集合。提供了数据存入和判断某条数据是否存在的机制。底层数据结构是二进制数组+多个无偏的hash函数。
                增加元素功能：(1)通过k个hash函数得到k个hash值。(2)将hash值对数组长度取模得到下标(3)将下标置1
                判断元素功能：(1)通过k个hash函数得到k个hash值。(2)将hash值对数组长度取模得到下标(3)判断下标是不是全都是1 如果都是1可能存在 如果有1个0则不存在
                使用多个hash函数的意义是：hash冲突是不能避免的，通过计算多个hash，只有全部一样才说明这个key存在，提高准确率。
                最佳实践：
                    (1)当用户注册的时候，直接从db中看看这个ID是否被注册，如果注册直接返回，如果没有注册。插入数据并且过滤器中添加这个ID。
                    一般都是后期引入，那么在启动之后，就将数据库的id都插入到过滤器中。
                    (2)当用户登录验证的时候，先判断布隆过滤器，如果不存在直接返回。如果存在先查缓存再查询数据库。查完数据库更新缓存。
            3. redis的内存淘汰策略
                (1)不进行数据淘汰的策略。超过缓存空间大小直接返回错误。
                进行数据淘汰策略。
                1.在设置过期时间的数据中淘汰。(1)过期时间到了就删除  (2)随机删除  (3)LRU算法删除  (4)LFU算法删除 
                2.在所有的数据中进行淘汰。    (1)随机删除    (2)LRU算法删除   (3)LFU算法删除
                LRU算法：删除最近最久没有使用的key
                LFU算法：根据数据使用了频率进行删除
            4. redis过期键的删除策略
                (1)定时删除。对key设置定时删除，其实是添加了一个监听器，到达过期时间的时候会生成一个时间事件，CPU检查这个事件组成的链表。然后遍历获取这个key，将key删除。缺点就是占用了CPU的资源。优点是及时删除，不占内存空间。
                (2)惰性删除。key过期后，并不删除这个key。而是等待下一次访问key的时候，判断是否已经超时。不占用CPU，但是消耗内存。
                (3)定期删除。是对前两种方案的中和。每隔一段时间执行一次删除过期键的操作，并通过限制删除操作的时长和频率减少删除操作对CPU时间的影响。
                源码  1.遍历所有的数据库  2.随机获取这个数据库的键，判断是否带过期时间。    3.如果是那就删除，如果不是那就跳过。 4.跳出循环的条件是 删除目标达成或者到达删除截止时间。
            5. redis的高可用
                1.主从服务。数据冗余备份，能够分担读请求的压力(读请求复杂均衡)。  缺点不能实现故障转移和单机性能限制
                2.哨兵模式。添加了故障转移的功能，还是有单机性能限制。
                3.集群服务。数据分片，能够整合多机器的优势。
                复制主要两个步骤  1.同步，也就是全量的复制(bgsave生成rdb文件发送给从服务器)  2.命令传播  (同步后生成一个缓冲区来记录之后的写操作 发送给从库)    
            6. redis的持久化
                RDB和AOF
                1.默认开启了RDB。 RDB命令是对当前redis中的数据进行快照拷贝，拷贝redis中的数据。生成了紧凑的二进制文件。
                具体是通过save和bgsave完成的。两者的不同是save命令由redis主线程执行，期间不能为外界提供服务。bgsave命令是fork一个子进程，由子进程执行拷贝任务，主进程依然能
                处理客户端的命令。  1min1w次  5min10次  15min1次就触发bgsave命令。
                优点：性能更高，文件进程体积小。  恢复更快。
                缺点：宕机可能丢失的数据比较多
                2.AOF。AOF文件是存储了写操作指令。
                写入缓冲区  文件写入  文件同步   相当于写入并且保存，这个刷盘的时机可以自己指定。 1s  always  no(由操作系统执行)
                优点：宕机信息不丢失
                缺点：性能比较差
                恢复的时候默认先使用AOF，因为AOF的数据一致性更强。
            6. redis的数据类型     字符串类型     哈希类型           列表类型         集合类型   有序集合类型    布隆过滤器               基数统计                位图                  地址信息
                  底层数据结构  简单动态字符串  哈希表(压缩表)   双向链表(压缩表)  整数数组(压缩表)   跳表(压缩表)   hash函数+二进制数组     粗略的计数(省内存)       bitMap 01(登录未登录)
            7. 如何保证缓存和数据库的一致性
                首先从业务上来分析：修改密码的同时 只有一个线程能够修改数据 可能由多个线程访问数据 业务明确。  几种解决方案  
                1. 先修改缓存后修改数据库来说，这种方案的风险很大。如果修改缓存成功但是修改mysql失败，导致数据不一致并且mysql存放的还是脏数据。
                2. 先修改数据库后修改缓存，在修改密码的时候，旧密码不能登录进系统。但是查询缓存还是正确的。 当然这种情况下在多个线程并发写的情况会出现问题。
                3. 删除缓存，更新数据库。当一个线程修改，另外一个线程读取的时候，将旧数据更新到redis中，不一致。
                4. 延时双删策略。 在删除缓存更新数据库的基础上，防止上面情况的发生，在修改数据库后等待一段时间重新删除缓存。
                缺点：保证了最终数据一致性，并不是强一致性。 但是需要消耗一点CPU资源。 一开始使用了当前线程阻塞并不好。
                应该交给一个延时任务去解决。
                5.如果redis挂了怎么处理。可以添加一个消息队列来解决(ack机制)。现在有开源项目专门监听binlog日志。放到消息队列中，然后消息队列消费消息去缓存中删除。
        (二)用户申请加入游戏
        (二.1)关于线程安全队列的选择
            1. ConcurrentLinkedQueue。从源码的角度来看，是基于CAS来实现的，也就是乐观锁。在增加节点的时候。先获取尾部节点。然后跑一个
            for循环，判断尾部节点是否已经修改将，tail.next=node 然后 tail.pre=node，然后return。
            但是在获取size的时候，看到这个size并没有任何的加锁。也就是当调用size的时候其实是跑了一个for循环 从队头到队尾，可以看到size是不准确的
            多线程对集合操作的时候，fast-fail，对业务产生重大的影响。
            2.ArrayBlockQueue。这两个集合中size方法都是使用了AtomicInteger来修饰的，并且直接获取这个值。符合业务需求。
            3.LinkedBlockQueue。主要从性能出发来选择，从源码中可以看到 linked是用了两把锁，一个负责放入元素，一个负责读出元素。array是使用了一把锁
            但是两个condition。很显然link效率更高。选择了linked。
        (二.2)线程通信问题
            为了解决用户选择加入游戏后不能执行其他操作。很多游戏中也就类似的设计。 等游戏结束后再返回receive线程。
            从思想上来看，主要就是两种实现方法。第一个共享内存，第二个消息传递。对应到Java中的实现。  volatile wait notify lock countdown 等等
            我使用了wait和notify实现。让player中，带一把锁。用户申请加入游戏后，直接加锁后，wait，然后等结束游戏后再次notify就回到了receive线程中。
        (四.1)关于skiplist的数据结构
            跳表基于链表，只不过在链表的基础上添加了跳跃的功能，实现简单，插入删除查找复杂度均为logN。
            每相邻的两个结点增加了一个指针，让指针指向下下个结点。所有新增加的指针连成新的链表，但是包含的结点个数只有原来的一半。比如查询时候，不需要每个结点逐个比骄傲。
            需要比较的节点数变成了原来的一半。可以在上层新链表上继续添加指针形成三层链表。跳过了很多下层结点，大大加快了查找速度。
        (四.2)skiplist的具体实现       
            1. 跳表的搜索：先从第一层开始查找最后一个小于k的数字。然后到第二层，然后继续刚才的操作。然后一直找到最后一层。直到找到这个值或者找到一个值大于这个值。
            2. 跳表的插入：先确定该元素占据的层数k（丢硬币的方式，完全随机，相当于丢硬币实验，如果正面继续丢，如果反面则停止）然后在k层插入元素。如果k大于层数则新建一层。（理论上来讲，一级索引元素个数占原来数据的50%，二级索引占25,三级索引占12.5%，所以每插入一个结点，都需要生成一个合理的层数，类似于抛硬币）
            3. 跳表的删除：找到最底层的这个结点。然后循环从底部朝上部删除。
        (四.3)如何实现线程安全
            1. 使用synchronized
            2. 使用reentrantLock
            3. 使用reentrantReadWriteLock
            4. 使用CAS算法来实现
        (五.1)普通购买
            这个没有什么好说的，就是有一个goods表，但是里面没有stock。一直是提供服务的。 先判断用户的balance是否足够，用户信息减少balance增加happybean创建订单，然后插入。更新内存中的信息。
        (五.2)活动抢购  秒杀活动
            

(三)亮点难点
    系统层面：如何保证线程安全，如何提高项目的并发量和QPS。
    用户层面：如何保证用户信息安全(用户密码的二次加密，MD5加盐，防止sql注入)，如何提升游戏体验(响应时间，心跳检测，半连接队列攻击)
    (三.1)如何保证线程安全
        1. 关于SqlSession线程不安全的解决方案。使用ThreadLocal实现
        2. 用户登陆后加入hashmap不安全的解决方案。<user,channel> 使用concurrentHashMap实现。
        3. 用户申请加入游戏的线程不安全。使用LinkedBlockQueue实现。
        4. 修改skiplist线程不安全解决方案。使用了synchronized--->reentrantLock--->reentReadWriteLock--->CAS实现。
        5. 如果面向分布式系统，业务拆分后，使用分布式锁解决修改数据库中happybean不安全。
    (三.2)如何提升项目并发量
        网络IO  磁盘IO  CPU资源的利用(线程数量的控制)
        1. IO的优化。sql语句的优化  网络IO的优化  BIO-->NIO--->Netty 
        2. 引入缓存层。
        3. 控制线程数量的优化。多线程+BIO  线程池+BIO  NIO   Netty  Netty+动态业务线程池
    (三.3)如何保证用户的信息安全
        1. 客户端发送的密码经过第一次MD5加密后在网络中传输。
        2. 服务器接收用户密码后进行加盐然后再次加密存放到数据库。
        3. 使用mybatis来解决sql注入,防止用户信息泄露。
    (三.4)如何提升游戏体验
        1. 对响应时间的提升。(1)BIO直接使用string类型交给TCP使用字节码传输。 (2)使用NIO使用string类型传输。 (3)使用Netty+ProtoBuf序列化后传输。 (4)使用异步处理快速得到响应。(6)内存实现skiplist (7)sql查询的优化，Top10，分页查询。
        2. 提供心跳检查机制，进行长时间离开退出游戏给出友好提示。或者服务器宕机给出友好提醒。(使用Netty来解决)
        3. 提供断线重连机制。因为网络中断后重新连接游戏。(1.一开始没连接上就重新连接  2.在游戏中中断触发重新连接)
        4. 关于半连接队列被占用导致正常用户不能登录，服务器的操作。
        5. 拆包粘包问题。
    详解
    (三.4.2)心跳检查
    
    (三.4.3)断线重连
        断线重连有两个地方会发生。第一个是一开始连接服务器的时候，调用一个doConnect()。
        doConnect()方法：调用connect()得到channelFuture。然后给这个channelFuture添加监听器。然后判断futureListener是不是成功。
        如果成功然后就将channel。 如果失败的话，开启netty的一个定时线程，然后重新执行doConnect。
        第二个是在传输的时候如果网络中断的话会触发 inactive方法，在这个方法中去执行doConnect。
    
    
    
    具体：1.sqlSession的解决    2.线程之间通信的问题   3.阻塞队列的选择问题 4.动态线程池的引入  5.线程的通信问题

(四)缺点
    前端页面的开发
    从高可用层面来看还需要做一些优化的工作。
    对mysql主从服务，数据冗余备份。
    对redis进行集群部署，提供性能。
    分布式



(五)代办
    1.threadlocal内存泄露的排查步骤
    3.半连接队列，如何防止攻击。
    5.分布式的场景下，怎么防止超卖？
    6.sql语句的优化
    7.心跳检查，断线重连。
    8.QPS的压力测试
    












