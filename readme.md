##############################双人棋牌游戏服务端开发##############################
1.0版本  Socket+多线程
2.0版本  Socket+线程池+解耦合
3.0版本  Netty
4.0版本  当前版本

(一)技术栈说明
    Socket   多线程  线程池  动态线程池
    SpringBoot  Netty  Redis  MYSQL  Mybatis  RabbitMQ  

(二)yml文件配置说明
    服务端客户端通信端口 8888
    Redis和RabbitMQ 使用192.168.23.131 centos7虚拟机
    数据库为本地 cardgame

(三)五大模块 
    1.登陆注册  
    2.进入游戏
    3.查询游戏记录
    4.查询排行榜
    5.抢购欢乐豆  

(四)协议的制定
    使用ProtoBuf来作为协议
    id1   表明  登录注册等哪个功能模块的编号
    id2   表明  每个模块的信息
    id3   备用
    context   发送的消息String
    注册         1   -----handlerInfo   1  1 注册成功   1  2注册失败
    登录         2   -----handlerInfo   2  1 登录成功   2  2登陆失败
    查询游戏信息   3   -----handlerInfo
    查询排行榜    4   -----handlerInfo
    加入游戏     5    -----handlerPlay
    开始游戏     6    -----handlerPlay    服务端发给客户端  6.0.1 开始游戏(先出牌)  6.0.2开始游戏(后出牌)   6.1 context(用户出的牌)   6.2 context(用户的牌或者对手的牌出完了 本局比赛结束)
                                         客户端发给服务端  6.0 不要    6.1要
    退出游戏     7    -----handlerPlay
    抢购欢乐豆   8    -----handlerSecKill
    购买欢乐豆   9    -----handlerBuy    
    修改密码     10   -----handlerInfo
    刷新用户信息  11   -----handlerFlush   用于用户购买欢乐豆成功后刷新用户的balance happybean
    同步客户端和服务端的时间      0  ------handlerSyncTime

(五)实现细节
    总体：
    1.使用fireChannelRead(msg) 可以使得msg在handler中继续传递
    (1)登录和注册
        使用了redis作为缓存，缓存用户的信息
        如何解决缓存穿透 和 缓存雪崩
        缓存穿透：参考mybatis的二级缓存  将数据库中没有的数据也插入到redis中
            在客户端限制客户的发送验证请求的次数 使用了定时任务
        缓存雪崩：两种情况，第一种是超时时间设置的一样，某个时间点请求打到数据库上
            第二种是redis宕机了
            解决方法：设置不同的过期时间的策略
                    使用主从复制和哨兵模式 搭建redis集群
    2.查询历史游戏记录
        如何实现分页功能？
    3.查询排行榜前十名
        (1)从synchronized到readwriteLock的升级
        (2)死锁的排查过程   readwriteLock 读锁中又出现了写锁
    4.加入游戏模块
        生产者消费者的思想解决
    5.开始游戏模块
        遇到了一个Bug @Data的使用
	    使用了异步线程池
    6.秒杀系统的设计
        (一)关于mysql级别解决数据库的超卖问题
            (1)减库存的sql语句上加上库存数量的判断。数据库滋生是有行锁的，每次减库存的时候
            判断count>0,实际上是串行的执行update。
            (2)实现乐观锁，给商品信息表增加了version字段，为每一条数据加上版本。每次更新的时候
            version+1，并且更新的时候带上版本号，当提交前版本号等于更新前版本号，说明此时没有被其他
            线程影响到，正常更新，如果冲突了就不会进行提交更新。当库存是足够的情况下发生乐观锁冲突就
            进行一定次数的重试。
        (二)减库存的操作
            (1)拍下减库存   目前采用拍下减库存 拍下就是一瞬间的事情，对用户的体验更好。
            (2)付款减库存
        具体流程：
        1.如何实现客户端和服务端时间的同步操作 
        1.使用springboot中的定时任务，每周六周天晚上八点更新redis和mysql中的信息  八点半删除redis和mysql中秒杀商品的信息
        2.用户发来秒杀的请求。首先判断用户的happybean和时间是否合法以及是否重购买。
        3.进入秒杀流程中
        4.三级判断  JVM的内存标记    redis中的库存是否充足
        5.如果充足的话那么预减redis的库存  (LUA脚本)
        6.然后给MQ的队列中发送一条消息，MessageInfo发给队列。
        7.消费者消费这个消息。 判断mysql中的库存是否充足，判断是否重复购买。(mysql中要加锁 并且设置组合索引)
        8.客户端轮询这个订单的状态。如果是在mysql中，那么插入成功，秒杀成功。  
        如果没有插入成功并且redis中这个货物的状态变为0(mysql执行减库存后判断库存数量=0设置这个标记)
        else  返回正在处理中。
    10.修改用户信息  如何保证数据库和redis的双写一致性
        CAP理论决定的，属于CAP中的AP。做到BASE理论的最终一致性。
        使用了延时双删策略。(先删除缓存 再次更新数据库  休眠一段时间再删除缓存)
        保证读请求结束，写请求可以删除读请求造成的缓存脏数据。
        关于update加锁的问题，如果是where后的列带索引加的是行锁，锁住索引。而且加了X锁。
        如果where条件没有使用索引，那就全局扫描。锁住了整张表

        

    


(六)面试
    1.ThreadLocal的应用  内存泄露
    2.对jvm的优化
    3.如何去解除死锁 发现死锁
    4.缓存击穿  缓存穿透 缓存雪崩的处理
    5.分页如何处理
    6.如何保证数据库和缓存的一致性
    7.用户取消订单怎么处理
    8.MQ延时队列 
    8.Netty中使用ThreadLocal在多个handler中进行变量的传播操作
    

(七)出现了问题 栈溢出的bug 循环依赖
    应该是UserVo中含有了User 还有一个UserVo的类
    未解决
    解决方法1：将UserVo中里面的User变量替换掉
    使用基本的数据类型来解决
    问题发现：是@Data注解带来的问题 因为UserVo的类中含有UserVo的引用 导致引用的循环依赖造成了栈溢出

(八)redis和mysql的缓存一致性的问题
1. redis做缓存的流程  
   1. 命中:先从缓存中读数据，如果命中，直接返回。
   2. 失效：先从缓存中读数据，如果没有命中，从数据库中读取，成功之后将数据放回缓存。
   3. 更新：先更新数据库再删除缓存。
2 .各种方案
      1. 先更新缓存再更新数据库  A更新缓存 B更新缓存 B更新数据库  A更新数据库 数据不一致
      2. 先更新数据库再更新缓存  A更新数据库 B更新数据库  B更新缓存  A更新缓存
      3. 先删除缓存再更新数据库  A删除缓存   B读取缓存发现不存在读数据库  A跟新数据库 B更新缓存  数据不一致
      4. 先更新数据库再删除缓存
         不正常的概率很小
         (1)正常的情况。先前缓存更好失效。A请求查数据库得到旧值A=1  B请求更新数据库 A=2  A请求将A=1写到缓存  B请求删除缓存
         (2)不正常情况。先前缓存刚好失效。A请求查数据库得到旧值A=1  B请求更新数据库 A=2  B请求删除缓存   A请求将旧值写入缓存 数据不一致性
         (3)解决方法：延时删除  请求B休眠100ms，等到请求A写入缓存之后再次删除
        
      5. 读写分离(主库复杂写 从库复杂读)
      用延时双删还是会出现问题
      解决方法 添加一个订阅binlog服务系统 主数据库更新后直接从订阅系统中 将redis的数据更新
      
      6. 更新缓存失败如何处理？
      增加一个消息队列 将更新缓存的数据放到MQ当中，消息队列中的消息是有序的并且可以进行持久化操作
      还能支持重试策略

3. 更新缓存的问题
   1. 如果跟新缓存逻辑复杂，更新缓存消耗大于直接淘汰cache。


4.关于数据库的乐观锁和悲观锁
    1.悲观锁。行锁，表锁，排他锁都是悲观锁。使用select for update语句，执行后会在表上加行锁，直到事务提交。解除行锁。
    2.乐观锁。多个线程同时CAS更新一个变量时候，只有一个线程能够更新成功。失败的线程不会被挂起。可以再次尝试。





缓存穿透
缓存穿透是指查询⼀个数据库⼀定不存在的数据。
⾼并发下，⼀秒钟前⼀百个请求向数据库请求，第⼀百零⼀个数据发现 缓存有了，就去访
问缓存，⽆影响。
⾼并发下，⼀秒钟⼀百万个请求都去请求⼀个数据，但是缓存没有，再去请求数据库，数
据库⾥也不存在，此时，这⼀百万个请求已经和数据库交互了。所以叫做绕过缓存，把
redis缓存数据库穿透了。
想象⼀下，uuid查询，很容易找到⼀个不存在的key，恶意攻击，利⽤这个漏洞，很容易给
服务器带来巨⼤的压⼒。
解决⽅案：把不存在的给个null，放⼊缓存，可以防⽌攻击⽤户反复⽤同⼀个id暴⼒攻击。
缓存雪崩
缓存雪崩：
指缓存中数据⼤批量到过期时间甚⾄缓存服务器宕机，⽽查询数据量巨⼤，引起数据库压
⼒过⼤甚⾄宕机。
和缓存击穿不同的是，缓存击穿指并发查同⼀条数据，缓存雪崩是不同数据都过期了，很
多数据都查不到从⽽查数据库。
解决⽅案：⼀般采取不同分类商品，设计随机因⼦，缓存不同周期。
缓存击穿
描述：缓存击穿是指缓存中没有但数据库中有的数据（⼀般是缓存时间到期），这时由于并发⽤
户特别多，同时读缓存没读到数据，⼜同时去数据库去取数据，引起数据库压⼒瞬间增⼤，造成
过⼤压⼒。
例⼦：爆款
解决⽅案：
设置热点数据永远不过期。

2022.5.1项目基本完成